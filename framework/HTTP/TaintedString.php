<?php

namespace Ufo\HTTP;




/**
 * class for one tainted string
 */
class TaintedString extends Tainted
{
    /**
     * @var boolean
     */
    protected $autogenerated = false;
    
	/**
	 * Clean string returned if safety test fail
	 * @var string
	 */
	protected $default_data = NULL;

	/**
	 * String that is tainted
	 * @var string
	 */
	protected $data;

    protected $preventTrim = false; 

	/**
	 * Constructor of the class.
	 * @param string $data		The string that is to be tainted
	 */
	public function __construct($data=null,$default_data=null)
	{
		$this->data = $data;
		$this->default_data = $default_data;
	}



	/**
	 * Function to trigger error when trying to use a string that is tainted
	 * @return string	The string that is tainted
	 */
	public function __toString()
	{
		if (Tainted::$TaintChecking and $this->Tainted)	//If the string is tainted, then trigger the error
			trigger_error("Trying to use tainted variable without decontamination.");
		
		if($this->data == null)
			return $this->default_data;
		else 
			return $this->data;
	}
	
	
	/**
	 * To prevent trim() when data is sanitized
	 * Chainable
	 * 
	 * @method TaintedString preventTrim()
	 * @return TaintedString 
	 */
	public function preventTrim()
	{
	    $this->preventTrim = true;
	    
	    return $this;
	}

	/**
	 *
	 */
	public function sanitizeWithCheck()
	{
	    $args = func_get_args();
	    $method = array_shift($args);
	    
	    $this->data = ($this->preventTrim == false)? trim($this->data) : $this->data ;
	    
	    array_unshift($args, $this->data);
	     
	    if( is_callable('\Ufo\Security\Check::'.$method)){
	        
	        if( call_user_func_array('\Ufo\Security\Check::'.$method, $args)){
	            $this->decontaminate();
	        }
	        else{            
	            $this->data = $this->default_data;
	            $this->decontaminate();
	        }
	        
	        return $this->data;
	    }
	    else{
	        throw new TaintedSanitizerErrorExcetion();
	        return null;
	    }
	}
	
	
	public function sanitizeAsObjectProperty()
	{
		$args = func_get_args();
		$callback = array_shift($args);
		
		$this->data = ($this->preventTrim == false)? trim($this->data) : $this->data ;
		
        if( (func_num_args() == 1) && is_callable($callback)){
            if( call_user_func($callback, $this->data)){
                $this->decontaminate();
                return $this->data;
            }
            else{
            	$this->decontaminate();
            	$this->data = $this->default_data;
                return $this->default_data;
            }
        }
        elseif( (func_num_args() > 1) && is_callable($callback)){
        	
        	array_push($args,$this->data);
        	
        	if( call_user_func_array($callback, $args)){
        		$this->decontaminate();
        		return $this->data;
        	}
        	else{
        		$this->decontaminate();
        		$this->data = $this->default_data;
        		return $this->default_data;
        	}
        }
		else{
		    throw new TaintedSanitizerErrorExcetion();
		    return null;
		}
	}
	
	/**
	 * 
	 * @param unknown $data_mixed
	 */
	public function setDefault( $data_mixed)
	{
		$this->default_data = $data_mixed;
		
		return $this;
	}
	
	
	/**
	 * Chainable
	 */
	public function markAsAutogenerated()
	{
	   $this->autogenerated = true;   
	   
	   return $this;
	}
	
	/**
	 * 
	 */
	public function isAutogenerated()
	{
        return $this->autogenerated;
	}

	/**
	 * 
	 * @return number
	 */
    public function length()
    {
        $this->data = ($this->preventTrim == false)? trim($this->data) : $this->data ;
        
        return strlen($this->data);
    }
    
    public function getDefaultData()
    {
        return $this->default_data;
    }
    
    public function getData(){ return $this->data; }
}

?>